import { useAxiosPrivate } from "@/app/hooks/useAxios";
import { Channel, useFetchChannels } from "@/app/hooks/useChannels";
import { WatchedChannel, WatchedChannelTitleRegex, useCreateWatchedChannel, useEditWatchedChannel } from "@/app/hooks/useWatchedChannels";
import { ActionIcon, Button, NumberInput, TextInput, Tooltip, Text, Divider, Checkbox, Select, Title, Box, Group, Grid, MultiSelect, Collapse } from "@mantine/core";
import { useForm } from "@mantine/form";
import { showNotification } from "@mantine/notifications";
import { IconPlus, IconTrash } from "@tabler/icons-react";
import { useEffect, useState } from "react";
import classes from "./Watched.module.css"
import { getTwitchCategories } from "@/app/hooks/useCategory";
import { useDisclosure } from "@mantine/hooks";
import Link from "next/link";
import { useTranslations } from "next-intl";
import { metadata } from "@/app/layout";

type Props = {
  watchedChannel: WatchedChannel | null
  mode: WatchedChannelEditMode
  handleClose: () => void;
}

export enum WatchedChannelEditMode {
  Create = "create",
  Edit = "edit",
}

const qualityOptions = [
  { label: "Best", value: "best" },
  { label: "1080p", value: "1080p" },
  { label: "720p", value: "720p" },
  { label: "480p", value: "480p" },
  { label: "360p", value: "360p" },
  { label: "160p", value: "160p" },
  { label: "audio", value: "audio" }
];

interface SelectOption {
  label: string;
  value: string;
}

const AdminWatchedChannelDrawerContent = ({ watchedChannel, mode, handleClose }: Props) => {
  const t = useTranslations('AdminWatchedComponents')
  const axiosPrivate = useAxiosPrivate()
  const [liveTitleRegexes, setLiveTitleRegexes] = useState<WatchedChannelTitleRegex[]>(
    watchedChannel?.edges.title_regex || []
  );

  const [channelSelect, setChannelSelect] = useState<SelectOption[]>([]);

  const [clipMoreInfoOpened, { toggle: clipMoreInfoToggle }] = useDisclosure(false);

  // Initialize edit watched channel mutation
  const editWatchedChannelMutation = useEditWatchedChannel();

  const form = useForm({
    mode: "controlled",
    initialValues: {
      id: watchedChannel?.id || "",
      watch_live: watchedChannel?.watch_live ?? false,
      watch_vod: watchedChannel?.watch_vod ?? false,
      download_archives: watchedChannel?.download_archives ?? true,
      download_highlights: watchedChannel?.download_highlights ?? true,
      download_uploads: watchedChannel?.download_uploads ?? true,
      resolution: watchedChannel?.resolution || "best",
      archive_chat: watchedChannel?.archive_chat ?? true,
      channel_id: watchedChannel?.edges.channel.id || "",
      render_chat: watchedChannel?.render_chat ?? true,
      download_sub_only: watchedChannel?.download_sub_only ?? false,
      video_age: watchedChannel?.video_age || 0,
      apply_categories_to_live: watchedChannel?.apply_categories_to_live ?? false,
      watch_clips: watchedChannel?.watch_clips ?? false,
      clips_limit: watchedChannel?.clips_limit || 5,
      clips_interval_days: watchedChannel?.clips_interval_days || 7,
      clips_ignore_last_checked: watchedChannel?.clips_ignore_last_checked ?? false,
      update_metadata_minutes: watchedChannel?.update_metadata_minutes || 15,
      live_title_regexes: [],
      categories: [] as string[],
    },
  })

  useEffect(() => {
    if (!watchedChannel || !watchedChannel.edges.categories) return

    const categories = watchedChannel.edges.categories.map((category) => category.name);
    form.setFieldValue('categories', categories);

    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [watchedChannel])

  const [twitchCategoriesLoading, setTwitchCategoriesLoading] = useState(false);
  const [formattedTwitchCategories, setFormattedTwitchCategories] = useState<SelectOption[]>([]);

  const handleGetTwitchCategories = async () => {
    try {
      setTwitchCategoriesLoading(true)

      const categories = await getTwitchCategories()
      if (!categories) return

      const tmpArr = categories.map((category) => ({
        label: category.name,
        value: category.name,
      })).filter((item, index, self) =>
        index === self.findIndex((t) => t.label === item.label)
      );

      setFormattedTwitchCategories(tmpArr);
    } catch (error) {
      console.error(error)
    } finally {
      setTwitchCategoriesLoading(false)
    }
  }

  const createWatchedChannelMutation = useCreateWatchedChannel();

  const handleSubmitForm = async () => {
    const formValues = form.getValues()

    try {
      if (mode === WatchedChannelEditMode.Create) {
        const newWatchedChannel: WatchedChannel = {
          id: "", // Will be generated by backend
          watch_live: formValues.watch_live,
          watch_vod: formValues.watch_vod,
          download_archives: formValues.download_archives,
          download_highlights: formValues.download_highlights,
          download_uploads: formValues.download_uploads,
          resolution: formValues.resolution,
          archive_chat: formValues.archive_chat,
          render_chat: formValues.render_chat,
          download_sub_only: formValues.download_sub_only,
          video_age: formValues.video_age,
          apply_categories_to_live: formValues.apply_categories_to_live,
          watch_clips: formValues.watch_clips,
          clips_limit: formValues.clips_limit,
          clips_interval_days: formValues.clips_interval_days,
          clips_ignore_last_checked: formValues.clips_ignore_last_checked,
          update_metadata_minutes: formValues.update_metadata_minutes,
          is_live: false, // Default value
          edges: {
            channel: { id: formValues.channel_id } as Channel,
            categories: [],
            title_regex: liveTitleRegexes
          },
          last_live: "",
          updated_at: "",
          created_at: ""
        };

        await createWatchedChannelMutation.mutateAsync({
          axiosPrivate,
          channelId: formValues.channel_id,
          watchedChannel: newWatchedChannel,
          categories: formValues.categories
        });

        showNotification({
          message: t('createNotification'),
          color: "green"
        });

        handleClose();
      } else if (mode === WatchedChannelEditMode.Edit && watchedChannel) {
        const updatedWatchedChannel: WatchedChannel = {
          ...watchedChannel,
          watch_live: formValues.watch_live,
          watch_vod: formValues.watch_vod,
          download_archives: formValues.download_archives,
          download_highlights: formValues.download_highlights,
          download_uploads: formValues.download_uploads,
          resolution: formValues.resolution,
          archive_chat: formValues.archive_chat,
          render_chat: formValues.render_chat,
          download_sub_only: formValues.download_sub_only,
          video_age: formValues.video_age,
          apply_categories_to_live: formValues.apply_categories_to_live,
          watch_clips: formValues.watch_clips,
          clips_limit: formValues.clips_limit,
          clips_interval_days: formValues.clips_interval_days,
          clips_ignore_last_checked: formValues.clips_ignore_last_checked,
          update_metadata_minutes: formValues.update_metadata_minutes,
          edges: {
            ...watchedChannel.edges,
            title_regex: liveTitleRegexes
          }
        };

        await editWatchedChannelMutation.mutateAsync({
          axiosPrivate,
          watchedChannel: updatedWatchedChannel,
          categories: formValues.categories
        });

        showNotification({
          message: t('editNotification'),
          color: "green"
        });

        handleClose();
      }
    } catch (error) {
      console.error(error);
      showNotification({
        message: mode === WatchedChannelEditMode.Create
          ? t('failedCreateNotification')
          : t('failedEditNotification'),
        color: "red"
      });
    }
  }


  const { data: channels } = useFetchChannels();

  useEffect(() => {
    if (!channels) return;

    const transformedChannels: SelectOption[] = channels.map((channel: Channel) => ({
      label: channel.name,
      value: channel.id,
    }));

    setChannelSelect(transformedChannels);
  }, [channels]);

  return (
    <div>
      <Text>{t.rich('headerText', {
        wiki: (chunks) => <a href="https://github.com/Zibbp/ganymede/wiki/Watched-Channels" target="_blank" className={classes.link}>{chunks}</a>,
      })}</Text>

      <form onSubmit={form.onSubmit(() => {
        handleSubmitForm()
      })}>
        <TextInput
          disabled={true}
          label={t('idLabel')}
          placeholder="Auto generated"
          key={form.key('id')}
          {...form.getInputProps('id')}
        />

        <Select
          disabled={mode == WatchedChannelEditMode.Edit}
          label={t('channelLabel')}
          data={channelSelect}
          key={form.key('channel_id')}
          {...form.getInputProps('channel_id')}
          searchable
        />

        <Select
          label={t('resolutionLabel')}
          data={qualityOptions}
          key={form.key('resolution')}
          {...form.getInputProps('resolution')}
          searchable
        />

        <Checkbox
          mt={10}
          label={t('archiveChatLabel')}
          key={form.key('archive_chat')}
          {...form.getInputProps('archive_chat', { type: "checkbox" })}
        />

        <Checkbox
          mt={5}
          label={t('renderChatLabel')}
          key={form.key('render_chat')}
          {...form.getInputProps('render_chat', { type: "checkbox" })}
        />

        <Divider my="sm" size="md" />

        <div>
          <Title order={3}>{t('liveStreamsText')}</Title>
          <Text>{t('liveStreamsDescription')}</Text>

          <Checkbox
            mt={5}
            label={t('watchLiveLabel')}
            key={form.key('watch_live')}
            {...form.getInputProps('watch_live', { type: "checkbox" })}
          />

          {form.values.watch_live && (
            <NumberInput
              mt={5}
              label={t('updateMetadataLabel')}
              description={t('updateMetadataDescription', { minutes: form.values.update_metadata_minutes })}
              key={form.key('update_metadata_minutes')}
              {...form.getInputProps('update_metadata_minutes')}
              min={1}
            />
          )}

        </div>

        <Divider my="sm" size="md" />

        <div>
          <Title order={3}>{t('videosText')}</Title>
          <Text>{t('videosDescription')}</Text>
          <Text size="xs" fs="italic">
            {t('videosOccurrence')}
          </Text>

          <Checkbox
            mt={5}
            label={t('watchVideosLabel')}
            key={form.key('watch_vod')}
            {...form.getInputProps('watch_vod', { type: "checkbox" })}
          />

          <Box ml={30}>
            <Checkbox
              mt={5}
              label={t('downloadArchivesLabel')}
              description={t('downloadArchivesDescription')}
              key={form.key('download_archives')}
              {...form.getInputProps('download_archives', { type: "checkbox" })}
            />
            <Checkbox
              mt={5}
              label={t('downloadHighlightsLabel')}
              description={t('downloadHighlightsDescription')}
              key={form.key('download_highlights')}
              {...form.getInputProps('download_highlights', { type: "checkbox" })}
            />
            <Checkbox
              mt={5}
              label={t('downloadUploadsLabel')}
              description={t('downloadUploadsDescription')}
              key={form.key('download_uploads')}
              {...form.getInputProps('download_uploads', { type: "checkbox" })}
            />
            <Checkbox
              mt={5}
              label={t('downloadSubOnlyLabel')}
              description={t('downloadSubOnlyDescription')}
              key={form.key('download_sub_only')}
              {...form.getInputProps('download_sub_only', { type: "checkbox" })}
            />
          </Box>
        </div>

        <Divider my="sm" size="md" />

        <div>
          <Title order={3}>{t('channelClipsText')}</Title>
          <Text>{t('channelClipsDescription')}</Text>
          <Text size="xs">
            {t('channelClipsDescription1')}
          </Text>

          <Link href="#">
            <Text c="blue" mt={5} size="xs" onClick={clipMoreInfoToggle}>{t('channelClipsMoreInformationButton')}</Text>
          </Link>
          <Collapse in={clipMoreInfoOpened}>
            <Text size="xs" mt={5}>
              {t('channelClipsMoreInformationText')}
            </Text>
          </Collapse>


          <Checkbox
            my={5}
            label={t('watchClipsLabel')}
            key={form.key('watch_clips')}
            {...form.getInputProps('watch_clips', { type: "checkbox" })}
          />


          <NumberInput
            label={t('numberOfClipsLabel')}
            description={t('numberOfClipsDescription')}
            key={form.key('clips_limit')}
            {...form.getInputProps('clips_limit')}
            min={1}
          />

          <NumberInput
            label={t('intervalDaysLabel')}
            description={t('intervalDaysDescription')}
            key={form.key('clips_interval_days')}
            {...form.getInputProps('clips_interval_days')}
            min={1}
          />

          <Checkbox
            mt={10}
            label={t('ignoreLastCheckedDateLabel')}
            description={t('ignoreLastCheckedDateDescription')}
            key={form.key('clips_ignore_last_checked')}
            {...form.getInputProps('clips_ignore_last_checked', { type: "checkbox" })}
          />

        </div>

        <Divider my="sm" size="md" />

        <div>
          <Title order={3}>{t('advancedText')}</Title>

          <NumberInput
            label={t('maxVideoAgeLabel')}
            description={t('maxVideoAgeDescription')}
            key={form.key('video_age')}
            {...form.getInputProps('video_age')}
          />

          <Group mt={5}>
            <Title order={5}>{t('titleRegexText')}</Title>
            <Tooltip label={t('titleRegexAddTooltip')}>
              <ActionIcon size="sm" variant="filled" color="green" aria-label="Add Title Regex" onClick={() => {
                const newRegex: WatchedChannelTitleRegex = {
                  apply_to_videos: false,
                  negative: false,
                  regex: "",
                  id: ""
                }
                setLiveTitleRegexes(liveTitleRegexes => [...(liveTitleRegexes ?? []), newRegex])
              }}>
                <IconPlus style={{ width: '70%', height: '70%' }} stroke={1.5} />
              </ActionIcon>
            </Tooltip>
          </Group>
          <div>
            <Text size="sm">{t.rich('titleRegexDescription', { wiki: (chunks) => <a href="https://github.com/Zibbp/ganymede/wiki/Watched-Channel-Title-Regex" target="_blank" className={classes.link}>{chunks}</a> })}</Text>
          </div>

          <div>
            {liveTitleRegexes && liveTitleRegexes.map((regex: WatchedChannelTitleRegex, index) => (
              <div key={index}>
                <Grid grow>
                  <Grid.Col span={10}>
                    <TextInput
                      label={t('titleRegexLabel')}
                      placeholder="(?i:rerun)"
                      value={regex.regex}  // Use the specific regex from the current item
                      onChange={(e) => {
                        const updatedRegexes = [...liveTitleRegexes];
                        updatedRegexes[index] = {
                          ...updatedRegexes[index],
                          regex: e.currentTarget.value,
                        };
                        setLiveTitleRegexes(updatedRegexes);
                      }}
                    />

                    <Group mt={7}>
                      <Checkbox
                        defaultChecked
                        label={t('negativeLabel')}
                        description={t('negativeDescription')}
                        checked={regex.negative}
                        onChange={(e) => {
                          const updatedRegexes = [...liveTitleRegexes];
                          updatedRegexes[index].negative = e.currentTarget.checked;
                          setLiveTitleRegexes(updatedRegexes)
                        }}
                      />
                      <Checkbox
                        defaultChecked
                        label={t('applyToVideosLabel')}
                        description={t('applyToVideosDescription')}
                        checked={regex.apply_to_videos}
                        onChange={(e) => {
                          const updatedRegexes = [...liveTitleRegexes];
                          updatedRegexes[index].apply_to_videos = e.currentTarget.checked;
                          setLiveTitleRegexes(updatedRegexes)
                        }}
                      />
                    </Group>
                  </Grid.Col>
                  <Grid.Col span={1} mt={25}>
                    <Group>
                      <ActionIcon size="lg" variant="filled" color="red" aria-label="Settings" h={80} onClick={() => {
                        const updatedRegexs = [...liveTitleRegexes]
                        updatedRegexs.splice(index, 1)
                        setLiveTitleRegexes(updatedRegexs)
                      }}>
                        <IconTrash style={{ width: '70%', height: '70%' }} stroke={1.5} />
                      </ActionIcon>
                    </Group>
                  </Grid.Col>
                </Grid>
              </div>
            ))}
          </div>
        </div>

        <Divider my="sm" size="md" />

        <div>
          <Title order={3}>{t('categoriesText')}</Title>
          <Text size="sm">{t('categoriesDescription')}</Text>
        </div>

        <Checkbox
          mt={5}
          label={t('categoriesApplyToLivestreamsLabel')}
          description={t('categoriesApplyToLivestreamsDescription')}
          key={form.key('apply_categories_to_live')}
          {...form.getInputProps('apply_categories_to_live', { type: "checkbox" })}
        />


        <Box mt={10}>
          {formattedTwitchCategories.length == 0 ? (
            <Button variant="filled" color="violet" onClick={() => handleGetTwitchCategories()}
              loading={twitchCategoriesLoading}
            >{t('categoriesLoadButton')}</Button>
          ) : (
            <MultiSelect
              searchable
              limit={20}
              data={formattedTwitchCategories}
              comboboxProps={{ position: 'top', middlewares: { flip: false, shift: false } }}
              placeholder={t('categoriesSearchPlaceholder')}
              clearable
              key={form.key('categories')}
              {...form.getInputProps('categories')}
            />
          )}
        </Box>

        <Button
          mt={10}
          type="submit"
          fullWidth
          loading={editWatchedChannelMutation.isPending}
        >
          {mode === WatchedChannelEditMode.Create ? t('submitButton') : t('editButton')}
        </Button>
      </form>

    </div>
  );
}

export default AdminWatchedChannelDrawerContent;